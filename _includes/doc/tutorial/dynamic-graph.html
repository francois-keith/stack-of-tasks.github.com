<h2>First steps with dynamic graph</h2>
<p>
  We assume that the stack of tasks has been installed using the installation instruction provided
  <a href="https://github.com/Stack-Of-Tasks/sot-doc/wiki/Installation">there</a>.
</p>

<h3>dynamic-graph 101</h3>

This first tutorial focuses on the dynamic-graph mecanism, which is the backbone of the stack of tasks framework.
This tutorial details ...

<p>
  As a toy example, let's realize this operation <code class="python">res=(a+b) * (c+d)</code> using dynamic-graph elements.
  The corresponding code would be this:
</p>

<pre><code class="python">from dynamic_graph import plug
from dynamic_graph.sot.core.operator import Add_of_double
from dynamic_graph.sot.core.operator import Multiply_of_double
a=1
b=2
c=3
d=4

# Crate  the entities
ad1  = Add_of_double('ad1')
ad2  = Add_of_double('ad2')
mult = Multiply_of_double('mult')

# Fix the values of the input for the first operation
ad1.sin1.value = a
ad1.sin2.value = b

# Fix the values of the input for the second operation
ad2.sin1.value = c
ad2.sin2.value = d

# plug all the signals
plug(ad1.sout, mult.sin1)
plug(ad2.sout, mult.sin2)
</code></pre>

In order to obtain the result of the multiplication, let's do:
<pre><code class="python">mult.sout.value
#> 0</code></pre>

This is normal.
At the creation of an entity, each of the signals has a default value associated to the time 0.
In order to have the new value, it is necessary to increment the time, so as to trigger the recomputation.
<pre><code class="python">mult.sout.time
#> 0
mult.sout.recompute(1)
mult.sout.value
#> 21</code></pre>

Let's now change one of the inputs of the entity ad1.
<pre><code class="python">ad1.sin1.value = 0</code></pre>

The result becomes:
<pre><code class="python">mult.sout.recompute(2)
mult.sout.value
#> 14</code></pre>

Note that the intermediary signal ad1.sout, has been updated, while ad2.sout hasn't:
<pre><code class="python">ad1.sout.time
#> 2
ad2.sout.time
#> 1</code></pre>

<h3>Dynamic-graph operations</h3>

<p>Here is a list of some basic operations that can be run on the entities/signals.
  A more complete list can be found in the cheat sheet (Documentation > Cheat sheet).
</p>

<table  border="1">
  <tr>
    <td colspan="2"><center><h4>Entity manipulation</h4></center></td>
  </tr>

  <tr>
    <td><code class="python">entity.help()</code></br></td>
    <td>Displays the help for an entity, namely the commands with their description</td>
  </tr>
  <tr>
    <td colspan="2">
      <pre><code class="python">ad1.help()
Linear combination of inputs
  - input  double
  -        double
  - output double
  sout = coeff1 * sin1 + coeff2 * sin2
  Coefficients are set by commands, default value is 1.

List of commands:
-----------------
setCoeff1:      	Set the coeff1.
setCoeff2:      	Set the coeff2.
</code></pre>
    </td>
  </tr>


  <tr>
    <td><code class="python">entity.help('command')</code></br></td>
    <td>Displays the complete help for the command (number of argument...)</td>
  </tr>
  <tr>
    <td colspan="2"><pre><code class="python">ad1.help('setCoeff1')
setCoeff1:

Set the coeff1.

Input:
 - a double.
Void return.
</code></pre>
    </td>
  </tr>


  <tr>
    <td><code class="python">entity.commands()</br></td>
    <td>Returns the list of commands of an entity, without description</td>
  </tr>
  <tr>
    <td colspan="2"><pre><code class="python">ad1.commands()
('setCoeff1', 'setCoeff2')
</code></pre>
    </td>
  </tr>


  <tr>
    <td><code class="python">entity.displaySignals()</br></td>
    <td>Lists the signals of an entity, indicates
      whether they are plugged or not.
      <ul>
        <li>AUTOPLUGGED: the signal is plugged to a signal of this entity, eventually internal</li>
        <li>PLUGGED: the signal is plugged to another one, from an other entity</li>
        <li>UNPLUGGED: the signal is not plugged. Requiring its recomputation will cause some issues</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td colspan="2">
      <pre><code class="python">ad1.displaySignals()
--- &lt;ad1&gt; signal list:
    |-- &lt;Sig:Add_of_double(ad1)::input(double)::sin1 (Type Cst) AUTOPLUGGED
    |-- &lt;Sig:Add_of_double(ad1)::input(double)::sin2 (Type Cst) AUTOPLUGGED
    `-- &lt;Sig:Add_of_double(ad1)::output(double)::sout (Type Fun)
    </code></pre>
    </td>
  </tr>


  <tr>
    <td colspan="2"><center><h4>Signal manipulation</h4></center></td>
  </tr>
  <tr>
    <td><code class="python">entity.signal.value</code></br></td>
    <td>Returns the current value of a signal </td>
  </tr>
  <tr>
    <td colspan="2"><pre><code class="python">ad1.sin1.value
0.0
</code></pre>
    </td>
  </tr>

  <tr>
    <td><code class="python">entity.signal.time</code></br></td>
    <td>Returns the current time of a signal </td>
  </tr>
  <tr>
    <td colspan="2">
      <pre><code class="python">ad1.sin1.time
2      </code></pre>
    </td>
  </tr>


  <tr>
    <td><code class="python">entity.signal.recompute(T)</code></br></td>
    <td>Force the recomputation of the signal for
      time T (only effective it the given time is
      greater than the current time).</td>
  </tr>

</table>

<h2>Going further</a></h2>

<p>
  More details on the internal graph structure used in the stack of tasks framework are provided in
  the <a href="https://github.com/jrl-umi3218/dynamic-graph-tutorial">dynamic-graph-tutorial</a>.
</p>

